\documentclass[10pt]{article}
\usepackage[a4paper,margin=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{listings}

% Configuración de listings para código
\lstset{
  basicstyle=\ttfamily\small,
  numbers=left,
  numberstyle=\tiny\color{gray},
  stepnumber=1,
  numbersep=8pt,
  backgroundcolor=\color{white},
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  frame=single,
  rulecolor=\color{black},
  tabsize=2,
  captionpos=b,
  breaklines=true,
  breakatwhitespace=false,
  title=\lstname,
  keywordstyle=\color{blue},
  commentstyle=\color{gray},
  stringstyle=\color{red},
  escapeinside={\%*}{*)},
  morekeywords={*,var,final,const,dynamic,void,String,int,double,bool,List,Map,Set,Future,async,await,class,extends,implements,with,mixin,enum,required,factory,static,this,super,null,true,false,new,return,if,else,for,while,do,switch,case,default,break,continue,try,catch,finally,throw,rethrow,assert}
}

% Definir Dart como alias de Java con palabras clave adicionales
\lstdefinelanguage{Dart}[]{Java}{
  morekeywords={var,final,const,dynamic,void,String,int,double,bool,List,Map,Set,Future,async,await,required,factory,late,part,library,import,export,show,hide,as,deferred,covariant,mixin,extension,on},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
  morestring=[b]',
}

% Rutas para los recursos gráficos (permite compilar desde la raíz o desde esta carpeta)
\graphicspath{{./}{./logo/}{./image/}}

% ============================================================
% CONFIGURACIÓN BÁSICA DEL TEMPLATE
% ============================================================
\newcommand{\institucion}{Universidad de Magallanes}
\newcommand{\facultad}{Departamento de Ingeniería en Computación}
\newcommand{\programa}{Ingeniería Civil en Computación e Informática}
\newcommand{\curso}{Taller de Integración}
\newcommand{\docente}{Dra. Patricia Maldonado}
\newcommand{\estudianteUno}{Diego Vidal}
\newcommand{\estudianteDos}{Bruno Martinez}
\newcommand{\titulo}{\textit{Aplicación de navegación interna para la Facultad de Ingeniería}}
\newcommand{\fechaentrega}{\textit{Fecha de entrega}}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\institucion}
\fancyhead[R]{\curso}
\fancyfoot[C]{\thepage}
\setlength{\headheight}{14.5pt}

\begin{document}

% ============================================================
% PORTADA
% ============================================================
\begin{center}
  \begin{tabular}{@{}c@{\hspace{1cm}}c@{\hspace{1cm}}c@{}}
    \raisebox{-0.5\height}{\includegraphics[height=2.5cm]{umag.png}} &
    \raisebox{-0.5\height}{%
      \begin{minipage}[c]{6cm}
        \centering
        {\Large \curso}\\[2mm]
        {\large \institucion}\\[3mm]
        {\Large \titulo}
      \end{minipage}%
    } &
    \raisebox{-0.5\height}{\includegraphics[height=2.5cm]{dic.png}}
  \end{tabular}
\end{center}

\vspace{4mm}
\begin{center}
  \includegraphics[width=0.65\textwidth]{placeholder.png}
\end{center}

\vspace{4mm}
\hrule
\vspace{1mm}
\hrule

\vspace{3mm}
\begin{tabular}{ll}
  Estudiantes: & \estudianteUno\\
              & \estudianteDos\\
  Programa: & \programa\\
  Departamento: & \facultad\\
  Profesor adjunto: & \docente\\
  Fecha: & \fechaentrega\\
\end{tabular}

\vspace{3mm}
\hrule
\vspace{1mm}
\hrule

\clearpage
\tableofcontents

\clearpage

% ============================================================
% RESUMEN
% ============================================================
\section*{Resumen}
\textit{El presente proyecto desarrolla una aplicacion de navegacion interna que tiene como fin optimizar la orientacion y el desplazamiento dentro de la facultad de ingenieria de la universidad de magallanes. Esta solucion viene de la necesidad de mejorar la accebilidad y la eficiencia a la hora de encontrar salas, oficinas y laboratorios, especialmente para estudiantes nuevos y personas visitantes. Para el desarrollo se implemento un sistema de mapeo digital basados en mapas arquitectonicos del edificio, integrando tecnologias de posicionamiento basadas en puntos de referencia.}

% ============================================================
% INTRODUCCIÓN
% ============================================================
\section{Introducción}
% La introducción debe tener las siguientes subsecciones según el formato [cite: 40]

\subsection{Antecedentes}
% 
Los alumnos cuando llegan por primera vez a la universidad pueden sentirse desorientados a la hora de ir a alguna sala o laboratorio ya que no sabe como llegar a esos lugares en especifico, para resolver esta problemática se busca crear una aplicación móvil para poder navegar dentro de la facultad.

\subsection{Período en que se realizó}
% 
El proyecto fue desarrollado en el segundo semestre del año 2025 en las dependencias de la facultad de ingeniería de la universidad de Magallanes. Las pruebas y evaluaciones se realizaron usando planos digitales y simulaciones de desplazamiento en sus principales pasillos y áreas de uso común.

\subsection{Objetivo General}
% 
Desarrollar una aplicación móvil de navegación interna que permita a los usuarios ubicarse y desplazarse eficientemente dentro de la Facultad de Ingeniería, utilizando tecnologías de posicionamiento y mapas digitales interactivos.

\subsection{Objetivos Específicos}
% 
\begin{itemize}
  \item Analizar la estructura espacial y las necesidades de orientación dentro de la Facultad de Ingeniería.
  \item Diseñar e implementar una interfaz intuitiva que muestre mapas internos y rutas óptimas hacia los distintos destinos.
  \item Integrar tecnologías de posicionamiento en interiores (beacons, Wi-Fi o códigos QR) que permitan determinar la ubicación del usuario en tiempo real.
\end{itemize}

% ============================================================
% DESARROLLO / HALLAZGOS / RESULTADOS
% ============================================================
\section{Desarrollo, hallazgos y resultados}
% 
% Esta sección se divide en Metodología y Presentación de Resultados [cite: 61]

\subsection{Metodología utilizada}
% 
Para la realización de este proyecto se siguieron las siguientes etapas:

\begin{enumerate}
  \item Digitalización de planos arquitectónicos de la facultad.
  \item Investigación sobre la creación de aplicaciones móviles.
  \item Preparación del entorno de desarrollo y repositorio de Github.
  \item Integración de los mapas a la aplicación.
  \item Creación de la interfaz gráfica de la aplicación.
  \item Modelado del grafo de salas y conexiones.
  \item Implementación del algoritmo de rutas.
  \item Implementación de funcionalidades extras a la aplicación.
  \item Pruebas piloto de la aplicación.
  \item Escalado a todos los pisos.
  \item Pruebas finales y ajustes.
\end{enumerate}

\subsection{Presentación de los Hallazgos y Resultados}
\subsubsection{Digitalización de planos arquitectónicos de la facultad}
Los mapas arquitectónicos de la facultad ya estaban digitalizados en formato DWG (formato usado por AutoCAD). Usando estos archivos como base, se hizo una conversión a otro formato para que fuera manipulable por un software gratuito que trabaje con archivos de mapas arquitectónicos. Los archivos fueron convertidos a formato DXF (Drawing Exchange Format) para posteriormente ser editados en el software LibreCAD.
Con LibreCAD se eliminaron elementos sin importancia para un mapa de navegación, como muebles y detalles decorativos, dejando solo las paredes y pasillos principales; también se corrigieron errores en los planos originales, ya que faltaban varias salas, laboratorios y oficinas.
Una vez que los planos se corrigieron y simplificaron, se exportaron a formato SVG (Scalable Vector Graphics) para su integración en la aplicación móvil. Pero la exportación directa a SVG desde LibreCAD no mantenía las proporciones correctas, lo que hacia que cuando se visualizara el mapa con un visor de imagenes o navegador web, este se viera demasiado pequeño o nisiquiera este se pudiera ver. Para corregir esto se utilizo un software de edición de imágenes vectoriales llamado Inkscape, donde se ajustaron las dimensiones del mapa para que se visualizaran correctamente en la aplicación móvil.

\subsubsection{Investigación sobre la creación de aplicaciones móviles}
Con el fin de elegir la mejor forma para poder desarrollar la aplicacion movil, se penso en que plataformas moviles que utilizan los estudiantes en la facultad como Android e IOS son las que mas se usan, por lo que se decidio primero investigar sobre las diferentes tecnologias y frameworks que existen para el desarrollo movil, las opciones eran las siguientes:
\begin{itemize}
  \item Desarrollo nativo: Crear aplicaciones independientes para cada plataforma (Java/Kotlin para Android y Swift/Objetive-C en el caso de IOS).
  \item Desarrollo multiplataforma: Utilizar frameworks como React Native, Flutter o Xamarin para desarrollar una sola base de código que funcione en ambas plataformas.
\end{itemize}

Despues de analizar las opciones, se opto por usar Flutter, ya que permite crear aplicaciones nativas de alto rendimiento para ambas plataformas desde una sola base de código, ademas de que tiene una gran comunidad de desarrolladores y una amplia gama de paquetes y plugins disponibles.

\subsubsection{Preparación del entorno de desarrollo y repositorio de Github}
Se prepararon los equipos para poder desarrollar la aplicacion movil (los equipos usados tenian como sistemas operativos Windows 10 y Debian 13), instalando Flutter SDK, un editor de codigo (Visual Studio Code) y los emuladores de Android e IOS para poder probar la aplicacion durante el desarrollo. Una vez teniendo el entorno de desarrollo listo, se creo un repositorio en Github para alojar el codigo fuente del proyecto y permitir la colaboracion entre los integrantes del equipo.

\subsubsection{Integración de los mapas a la aplicación}
Con la interfaz gráfica ya creada, se agregaron los mapas al proyecto para poder visualizarlos dentro de la aplicación. Una vez integrados los mapas, estos se logran visualizar bien y su interacción con el usuario es buena.

Un detalle a destacar: el mapa del primer piso y el de los laboratorios al ser mapas independientes sería complicado trabajarlos por separados, por lo que la mejor opción a tomar es fusionar ambos mapas para evitar complicaciones futuras con la aplicación.

\subsubsection{Creación de la interfaz gráfica}
La interfaz gráfica de la aplicación se desarrolló usando Flutter como framework principal, aprovechando su capacidad de crear interfaces nativas y fluidas con un único código base. El diseño de la app se enfocó en la simplicidad y usabilidad, considerando que los usuarios principales serían estudiantes nuevos y visitantes que necesitan orientarse rápidamente dentro de la facultad.

\paragraph{Estructura de la aplicación}
La aplicación se estructuró en dos pantallas principales que permiten una navegación intuitiva:

\textbf{Pantalla de inicio (PantallaInicio).} Esta pantalla funciona como punto de entrada de la aplicación y presenta las siguientes características:

\begin{itemize}
  \item \textbf{Diseño visual atractivo}: Se implementó un gradiente de color que va desde un azul claro en la parte superior hasta blanco en la parte inferior, creando una interfaz agradable visualmente y manteniendo la identidad institucional mediante el uso del color azul.

  \item \textbf{Encabezado informativo}: En la parte superior se muestra un ícono de ubicación de gran tamaño junto con el título ``Navegación Interna'' y un subtítulo descriptivo, lo que permite al usuario identificar inmediatamente el propósito de la aplicación.

  \item \textbf{Sistema de tarjetas por piso}: La funcionalidad principal se presenta mediante cuatro tarjetas interactivas, una por cada piso de la facultad. Cada tarjeta incluye:
  \begin{itemize}
    \item Un ícono distintivo que representa el tipo de espacios del piso (ciencia para laboratorios, escuela para aulas, libro para salas de estudio, y edificio para administración)
    \item Un título claro con el nombre del piso
    \item Una descripción breve de los espacios que contiene
    \item Un indicador visual de navegación (flecha)
    \item Códigos de color diferenciados (verde, naranja, morado y rojo) para facilitar la identificación rápida
  \end{itemize}
\end{itemize}

Esta organización permite que el usuario seleccione rápidamente el piso que desea explorar con solo tocar la tarjeta correspondiente.

\textbf{Pantalla de mapa (PantallaMapa).} Una vez seleccionado un piso, el usuario es dirigido a la pantalla de mapa, que constituye el componente central de la aplicación. Esta pantalla implementa las siguientes funcionalidades:

\begin{itemize}
  \item \textbf{Visualización de mapas SVG}: Se integró el paquete \texttt{flutter\_svg} para cargar y mostrar los mapas arquitectónicos en formato SVG. La aplicación determina dinámicamente qué archivo SVG cargar según el piso seleccionado, utilizando las rutas:
  \begin{itemize}
    \item Primer piso: \texttt{Mapas/Primer piso labs\_fac\_ing simple.svg}
    \item Segundo piso: \texttt{Mapas/Segundo piso fac ing simple.svg}
    \item Tercer piso: \texttt{Mapas/Tercer piso fac\_ing simple.svg}
    \item Cuarto piso: \texttt{Mapas/Cuarto piso fac\_ing simple.svg}
  \end{itemize}

  \item \textbf{Navegación interactiva}: Se implementó el widget \texttt{InteractiveViewer} de Flutter, que proporciona:
  \begin{itemize}
    \item Desplazamiento táctil para explorar diferentes áreas del mapa
    \item Zoom mediante gestos de pellizco en pantallas táctiles
    \item Límites de escala configurables (mínimo 0.3x, máximo 5.0x) para mantener la visualización en rangos útiles
  \end{itemize}

  \item \textbf{Controles de zoom}: Se añadieron tres botones flotantes en la parte inferior derecha que permiten:
  \begin{itemize}
    \item Acercar el mapa (zoom in) aumentando la escala en un 20\%
    \item Alejar el mapa (zoom out) reduciendo la escala en un 20\%
    \item Reiniciar la vista al estado inicial, útil cuando el usuario pierde orientación
  \end{itemize}

  \item \textbf{Gestión de estados de carga}: La aplicación implementa un sistema robusto para manejar diferentes estados:
  \begin{itemize}
    \item Estado de carga: Muestra un indicador circular de progreso con el texto ``Cargando mapa...''
    \item Estado de error: En caso de que el archivo SVG no se encuentre o no pueda cargarse, se muestra un mensaje de error detallado con el ícono de advertencia, el nombre del archivo que se intentó cargar y la descripción del error específico
  \end{itemize}

  \item \textbf{Barra informativa}: Se incluyó una barra azul claro debajo del encabezado que muestra el nombre del piso actual y proporciona una indicación visual de que se puede hacer zoom con gestos de pellizco.
\end{itemize}

\paragraph{Implementación técnica}

\textbf{Widget principal y navegación.} La aplicación utiliza \texttt{MaterialApp} como widget raíz, configurando el tema principal con Material Design 3 (\texttt{useMaterial3: true}) para aprovechar los componentes de diseño más modernos de Flutter. El sistema de navegación se basa en \texttt{Navigator.push()}, que permite transiciones fluidas entre la pantalla de inicio y las pantallas de mapas.

\textbf{Gestión de transformaciones.} Para controlar el zoom y desplazamiento del mapa, se implementó un \texttt{TransformationController} que mantiene una matriz de transformación 4x4 (\texttt{Matrix4}). Esta matriz permite aplicar operaciones de escala y traslación al mapa de forma eficiente, proporcionando una experiencia de usuario fluida incluso con mapas de gran tamaño.

Las operaciones de zoom se realizan clonando la matriz actual, aplicando la escala deseada y actualizando el controlador, lo que garantiza que las transformaciones se realicen de forma acumulativa y coherente.

\textbf{Carga asíncrona de recursos.} La aplicación implementa un patrón de carga asíncrona mediante \texttt{FutureBuilder}, que permite mostrar indicadores de progreso mientras se cargan los archivos SVG. Este enfoque mejora significativamente la experiencia del usuario, especialmente en dispositivos con menor rendimiento o cuando los archivos de mapa son de gran tamaño.

\paragraph{Consideraciones de diseño}

Durante el desarrollo de la interfaz se tomaron varias decisiones importantes:

\begin{enumerate}
  \item \textbf{Material Design}: Se adoptó el sistema de diseño Material de Google para garantizar consistencia visual y aprovechar componentes probados en cuanto a usabilidad.

  \item \textbf{Retroalimentación visual}: Todos los elementos interactivos proporcionan retroalimentación visual mediante efectos de elevación (\texttt{elevation}) en las tarjetas y efectos de onda (\texttt{InkWell}) al tocar.

  \item \textbf{Accesibilidad}: Se implementaron tooltips en todos los botones de acción para ayudar a los usuarios a comprender la funcionalidad de cada control.

  \item \textbf{Manejo de errores}: Se diseñó una pantalla de error informativa que no solo indica que algo salió mal, sino que proporciona detalles técnicos útiles para diagnosticar el problema.
\end{enumerate}

Esta implementación inicial de la interfaz gráfica estableció las bases para el desarrollo posterior de funcionalidades más avanzadas, como el sistema de navegación basado en grafos y el cálculo de rutas óptimas entre diferentes puntos de la facultad.

\subsubsection{Modelado del grafo de salas y conexiones}
La aplicación hace uso de un modelo de grafo para poder representar la topología de cada piso del edificio (dicho de otra forma se representa mediante el grafo las salas de clase, oficinas y laboratorio de toda la facultad de ingeniería). Este modelo permite calcular las mejores rutas entre distintos puntos de interés mediante algoritmos de búsqueda en grafos.

\paragraph{Estructura del modelo de datos}
\textbf{Clase Nodo.} Representa un punto de interés en el mapa (Sala, laboratorio, oficina, etc.).
\begin{lstlisting}[language=Dart, caption={Clase Nodo}]
class Nodo {
  final String id; // Ejemplo: "P1_A101"
  final double x; // Coordenada X en el mapa SVG
  final double y; // Coordenada Y en el mapa SVG

  Nodo({required this.id, required this.x, required this.y});

  factory Nodo.fromJson(Map<String, dynamic> json) {
    return Nodo(id: json['id'], x: json['x'], y: json['y']);
  }

  Map<String, dynamic> toJson() => {'id': id, 'x': x, 'y': y};
}
\end{lstlisting}

\textbf{Clase Conexion.} Representa una arista entre dos nodos, con la información de distancia.
\begin{lstlisting}[language=Dart, caption={Clase Conexion}]
class Conexion {
  final String origen;      // ID del nodo origen
  final String destino;     // ID del nodo destino
  final double distancia;   // Distancia euclidiana
  
  const Conexion({required this.origen, 
                  required this.destino, 
                  required this.distancia});
  
  factory Conexion.fromJson(Map<String, dynamic> json) {
    return Conexion(
      origen: json['origen'] as String,
      destino: json['destino'] as String,
      distancia: (json['distancia'] as num).toDouble(),
    );
  }
}
\end{lstlisting}

\textbf{Clase Grafo.} Contenedor principal que agrupa los nodos y conexiones de un piso.
\begin{lstlisting}[language=Dart, caption={Clase Grafo}]
class Grafo {
  final List<Nodo> nodos;
  final List<Conexion> conexiones;
  
  const Grafo({required this.nodos, required this.conexiones});
  
  factory Grafo.fromJson(Map<String, dynamic> json) {
    return Grafo(
      nodos: (json['nodos'] as List<dynamic>)
          .map((e) => Nodo.fromJson(e as Map<String, dynamic>))
          .toList(),
      conexiones: (json['conexiones'] as List<dynamic>)
          .map((e) => Conexion.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }
}
\end{lstlisting}

\paragraph{Sistema de tipificación de nodos}
La aplicación implementa un sistema de clasificación de nodos mediante un \texttt{enum} que permite separar por categorías a los diferentes nodos que hay en el mapa. Se definió el \texttt{enum TipoNodo} con los valores: entrada, pasillo, intersección, esquina, puerta, escalera, ascensor, baño y punto de interés.

Cada tipo de nodo tiene asociado un nombre legible, un icono representativo y un color distintivo mediante una extensión que proporciona propiedades adicionales para facilitar su visualización en la interfaz gráfica.

La aplicación puede inferir el tipo de nodo basándose en el ID del nodo mediante análisis de subcadenas en el identificador. Por ejemplo, si el ID contiene ``entrada'', se clasifica como \texttt{TipoNodo.entrada}; si contiene ``ascensor'', se clasifica como \texttt{TipoNodo.ascensor}, y así sucesivamente.

\paragraph{Sistema de coordenadas}
\textbf{Normalización SVG.} El sistema utilizado para las coordenadas fue normalizar las coordenadas del archivo SVG a $1200 \times 800$ píxeles, para todos los pisos, independientemente del tamaño real del archivo SVG. Esto permite:
\begin{itemize}
  \item Consistencia entre los distintos pisos
  \item Simplificación del cálculo de las distancias
  \item Escalado dinámico a cualquier resolución de pantalla
\end{itemize}

\textbf{Transformación de coordenadas.} La aplicación implementa un sistema de transformación bidireccional. Para la transformación de SVG a pantalla, se calcula la escala manteniendo el aspect ratio (BoxFit.contain), se determinan las dimensiones escaladas y los offsets para centrado, y finalmente se aplica la transformación a las coordenadas. Para la transformación inversa de pantalla a SVG, se aplica la operación inversa restando los offsets y dividiendo por la escala.

\paragraph{Estructura de archivos JSON}
Cada piso de la facultad tiene su archivo JSON correspondiente con una estructura que incluye un array de nodos (con propiedades id, x, y, tipo y nombre) y un array de conexiones (con origen, destino y distancia).

Los identificadores de nodos siguen el patrón \texttt{P\{piso\}\_\{tipo\}\{numero\}}, por ejemplo:
\begin{itemize}
  \item \texttt{P1\_Entrada} para la entrada de la facultad
  \item \texttt{P2\_Sala\_23} para la sala 23 del segundo piso
  \item \texttt{P3\_Departamento\_matematica\_fisica} para el departamento de matemática y física del tercer piso
\end{itemize}

Los archivos se ubican en la ruta \texttt{lib/data/} con los nombres \texttt{grafo\_piso1.json}, \texttt{grafo\_piso2.json}, \texttt{grafo\_piso3.json} y \texttt{grafo\_piso4.json}.

\paragraph{Carga dinámica del grafo}
La aplicación implementa una utilidad de carga (\texttt{grafo\_loader.dart}) que permite cargar asíncronamente los archivos JSON desde los assets del proyecto. La función determina dinámicamente qué archivo cargar según el número de piso seleccionado, lee el contenido del archivo mediante \texttt{rootBundle.loadString()}, decodifica el JSON y crea las instancias de las clases del modelo de datos.

La inicialización del mapa se realiza de forma asíncrona, cargando primero los nodos y esperando al primer frame para tener el RenderBox disponible antes de marcar el componente como inicializado.

\paragraph{Visualización de nodos}
Los nodos se visualizan en el mapa como marcadores circulares sobre el mapa SVG. Cada marcador se posiciona utilizando las coordenadas transformadas del sistema SVG al sistema de la pantalla, con un tamaño de 12×12 píxeles.

Los marcadores incluyen:
\begin{itemize}
  \item Color de fondo según el tipo de nodo (inferido o explícito)
  \item Forma circular con borde blanco de 1.5 píxeles
  \item Sombra para mejorar la visibilidad
  \item Icono representativo del tipo de nodo (puerta, pasillo, escalera, etc.)
  \item Interactividad mediante \texttt{GestureDetector} para mostrar información al tocar
\end{itemize}

\paragraph{Herramientas de desarrollo}
La aplicación incluye un modo de desarrollo para facilitar la creación del grafo. Este modo permite:

\begin{itemize}
  \item \textbf{Captura de coordenadas}: Tocar el mapa en modo debug registra las coordenadas SVG del punto seleccionado
  \item \textbf{Creación de nodos}: Un diálogo permite especificar el tipo y el ID del nodo, generando automáticamente el JSON correspondiente
  \item \textbf{Generación automática de IDs}: Los identificadores se generan siguiendo el patrón establecido, incluyendo el número de piso y un timestamp
  \item \textbf{Creación de conexiones}: Interfaz para seleccionar nodo origen y destino, calculando automáticamente la distancia euclidiana
  \item \textbf{Visualización de conexiones}: Las conexiones se muestran como líneas con flechas direccionales y etiquetas de distancia
  \item \textbf{Exportación de datos}: Funcionalidad para copiar al portapapeles el JSON generado de nodos y conexiones
  \item \textbf{Estadísticas}: Visualización de la cantidad de nodos por tipo y validación de la integridad del grafo
  \item \textbf{Migración de tipos}: Herramienta para agregar automáticamente tipos a nodos existentes mediante inferencia
  \item \textbf{Recarga dinámica}: Capacidad de recargar los nodos desde el archivo JSON sin reiniciar la aplicación
\end{itemize}

El modo debug utiliza marcadores visuales de color naranja para diferenciar los puntos capturados de los nodos permanentes del grafo, y permite activarse o desactivarse mediante un botón en la interfaz.

\subsubsection{Implementación del algoritmo A* para cálculo de rutas}
Para calcular las mejores rutas entre los distintos puntos de interés dentro de la facultad, se implementó un algoritmo de búsqueda en grafos. El algoritmo elegido fue \textbf{A* (A estrella)}, un método de búsqueda heurística que encuentra la ruta más corta entre dos puntos dentro de un grafo.

\paragraph{Fundamentos del algoritmo A*}
A* es un algoritmo de búsqueda informada que combina dos valores fundamentales:
\begin{itemize}
  \item $g(n)$: el costo real acumulado desde el nodo inicial hasta el nodo $n$
  \item $h(n)$: una heurística que estima el costo faltante desde el nodo $n$ hacia el objetivo
\end{itemize}

De este modo, evalúa cada nodo mediante la función:
\begin{equation}
f(n) = g(n) + h(n)
\end{equation}

Esta combinación permite que A* sea eficiente y encuentre rutas óptimas siempre que la heurística sea admisible (no sobreestima el costo real). La heurística utilizada en la aplicación es la \textbf{distancia euclidiana} basada en las coordenadas $(x, y)$ de los nodos:
\begin{equation}
h(n_1, n_2) = \sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2}
\end{equation}

\paragraph{Implementación en Dart}
La implementación se realizó en el archivo \texttt{a\_estrella.dart}, integrándose con la clase \texttt{Grafo} que modela los nodos (con sus coordenadas) y la adyacencia entre ellos.

\textbf{Estructura de la clase AStar.} Se creó la clase \texttt{AStar}, que funciona en dos modos para mantener flexibilidad:
\begin{itemize}
  \item Como \textbf{instancia}, recibiendo un objeto \texttt{Grafo} y proporcionando un método \texttt{calcular()}
  \item Como \textbf{API estática}, mediante \texttt{AStar.calcularRuta()}, manteniendo compatibilidad con versiones previas
\end{itemize}

\begin{lstlisting}[language=Dart, caption={Estructura de la clase AStar}]
class AStar {
  final Grafo grafo;
  AStar(this.grafo);

  List<String> calcular({required String origen, 
                         required String destino}) {
    return AStar.calcularRuta(
      grafo: grafo, 
      origen: origen, 
      destino: destino
    );
  }
}
\end{lstlisting}

\textbf{Mapa de adyacencias.} El algoritmo genera primero un mapa de adyacencias a partir del grafo, donde cada nodo queda asociado a sus vecinos con los costos de distancia correspondientes:

\begin{lstlisting}[language=Dart]
final mapa = grafo.generarMapaAdyacencia();
final nodos = grafo.nodos;
final nodosMap = {for (var n in nodos) n.id: n};
\end{lstlisting}

\textbf{Tablas internas del algoritmo.} Se inicializan tres estructuras de datos esenciales:
\begin{itemize}
  \item \texttt{gScore}: almacena el costo acumulado desde el origen
  \item \texttt{fScore}: almacena el costo estimado total ($f = g + h$)
  \item \texttt{prev}: registra los predecesores para reconstruir la ruta
\end{itemize}

Todos los valores comienzan como infinito excepto el nodo inicial:
\begin{lstlisting}[language=Dart]
for (var n in mapa.keys) {
  gScore[n] = double.infinity;
  fScore[n] = double.infinity;
  prev[n] = null;
}
gScore[origen] = 0;
fScore[origen] = _heuristica(nodosMap[origen]!, 
                              nodosMap[destino]!);
\end{lstlisting}

\textbf{Proceso principal del algoritmo.} El algoritmo itera sobre un conjunto de nodos abiertos siguiendo estos pasos:

\begin{enumerate}
  \item Selecciona el nodo con menor \texttt{fScore} del conjunto abierto
  \item Si es el destino, reconstruye la ruta y finaliza
  \item Si no, revisa cada vecino del nodo actual:
  \begin{itemize}
    \item Calcula un costo tentativo: $g_{tentativo} = g_{actual} + distancia(actual, vecino)$
    \item Si es menor al costo conocido, actualiza \texttt{gScore}, \texttt{fScore} y \texttt{prev}
    \item Agrega el vecino al conjunto abierto
  \end{itemize}
\end{enumerate}

\begin{lstlisting}[language=Dart, caption={Bucle principal de A*}]
final abiertos = <String>{origen};

while (abiertos.isNotEmpty) {
  final actual = abiertos.reduce(
    (a, b) => fScore[a]! < fScore[b]! ? a : b
  );
  
  if (actual == destino) {
    return _reconstruir(prev, destino);
  }
  
  abiertos.remove(actual);
  
  for (var vecino in mapa[actual]!.keys) {
    final tentativeG = gScore[actual]! + mapa[actual]![vecino]!;
    
    if (tentativeG < gScore[vecino]!) {
      prev[vecino] = actual;
      gScore[vecino] = tentativeG;
      fScore[vecino] = tentativeG + 
          _heuristica(nodosMap[vecino]!, nodosMap[destino]!);
      abiertos.add(vecino);
    }
  }
}
return []; // No se encontro ruta
\end{lstlisting}

\textbf{Reconstrucción de la ruta.} Cuando se alcanza el nodo destino, se reconstruye el camino recorriendo el mapa de predecesores desde el objetivo hacia el origen:

\begin{lstlisting}[language=Dart, caption={Reconstrucción de la ruta}]
static List<String> _reconstruir(
    Map<String, String?> prev, 
    String destino) {
  final ruta = <String>[];
  var actual = destino;
  
  while (prev[actual] != null) {
    ruta.insert(0, actual);
    actual = prev[actual]!;
  }
  
  ruta.insert(0, actual); // Agregar origen
  return ruta;
}
\end{lstlisting}

\paragraph{Integración con la interfaz gráfica}
El algoritmo se integró con la interfaz desarrollada en Flutter mediante la pantalla de selección de destino (\texttt{pantalla\_seleccion\_destino.dart}). El proceso de uso es el siguiente:

\begin{enumerate}
  \item El usuario escanea un código QR que identifica su ubicación actual (nodo origen)
  \item Se abre una pantalla que muestra el origen y permite seleccionar el destino mediante un menú desplegable
  \item Al presionar ``Calcular Ruta'', se crea una instancia de \texttt{AStar}:
  \begin{lstlisting}[language=Dart]
final ruta = AStar.calcularRuta(
  grafo: widget.grafo,
  origen: widget.nodoOrigenId,
  destino: _nodoDestinoSeleccionado!,
);
  \end{lstlisting}
  \item La ruta resultante es una lista ordenada de IDs de nodos
  \item La distancia total se calcula sumando las distancias euclidianas entre nodos consecutivos
  \item La aplicación visualiza el recorrido paso a paso en una lista numerada
  \item Al confirmar, la ruta se dibuja sobre el mapa SVG mediante un \texttt{CustomPainter} (\texttt{RutaPainter})
\end{enumerate}

\paragraph{Visualización de rutas en el mapa}
La clase \texttt{RutaPainter} implementa un pintor personalizado que dibuja la ruta calculada sobre el mapa:

\begin{itemize}
  \item Convierte los IDs de nodos a coordenadas de pantalla
  \item Dibuja líneas conectando los nodos secuencialmente
  \item Utiliza colores distintivos (azul para el camino, verde para origen, rojo para destino)
  \item Agrega efectos visuales como sombras y gradientes para mejorar la legibilidad
  \item Dibuja círculos en cada nodo de la ruta para destacar los puntos de paso
\end{itemize}

Este proceso permite navegación precisa entre salas, laboratorios, oficinas y pasillos, proporcionando al usuario una guía visual clara para desplazarse dentro de la facultad.

\paragraph{Ventajas de A* sobre alternativas}
La elección de A* sobre el algoritmo de Dijkstra se justifica por varias razones:
\begin{itemize}
  \item \textbf{Eficiencia}: A* explora menos nodos al usar la heurística para guiar la búsqueda hacia el objetivo
  \item \textbf{Optimalidad}: Garantiza encontrar la ruta más corta cuando la heurística es admisible
  \item \textbf{Rendimiento}: En grafos espaciales como los mapas de edificios, la distancia euclidiana es una excelente heurística que reduce significativamente el espacio de búsqueda
  \item \textbf{Escalabilidad}: El algoritmo funciona eficientemente incluso con grafos grandes (los 4 pisos suman más de 100 nodos)
\end{itemize}

\paragraph{Integración con el sistema de navegación por QR}
El sistema de códigos QR permite a los usuarios escanear marcadores físicos ubicados en puntos estratégicos de la facultad. Cada código QR contiene información en formato JSON que identifica un nodo específico del grafo:

\begin{lstlisting}[language=Dart, caption={Formato de códigos QR}]
{
  "type": "nodo",
  "id": "P1_Entrada_1",
  "piso": 1,
  "x": 100,
  "y": 200
}
\end{lstlisting}

La aplicación valida y parsea estos códigos mediante la clase \texttt{QRUtils} en \texttt{codigo\_qr.dart}, que soporta múltiples formatos (JSON moderno y formatos legacy) para mantener compatibilidad. Una vez identificado el nodo origen, A* calcula la ruta óptima al destino seleccionado por el usuario.

\paragraph{Conclusión sobre la implementación de A*}
La integración del algoritmo A* con el modelo de grafos y la interfaz gráfica permite una experiencia de navegación interna eficiente y clara. El algoritmo determina rutas óptimas usando distancias reales y una heurística adecuada para espacios 2D, mientras Flutter proporciona la visualización interactiva del plano de la facultad.

Este diseño modular facilita extender la aplicación a nuevos pisos o edificios simplemente añadiendo los mapas SVG correspondientes y sus archivos JSON de grafos, sin necesidad de modificar la lógica del algoritmo de búsqueda.



% ============================================================
% CONCLUSIONES Y RECOMENDACIONES
% ============================================================
\section{Conclusiones y Recomendaciones}
% 
Redacte conclusiones breves destacando los aprendizajes clave y si se cumplieron los objetivos[cite: 83]. Añada recomendaciones si es pertinente[cite: 86].

% ============================================================
% REFERENCIAS
% ============================================================
\section{Referencias}
% [cite: 33]
% El formato solicitado es IEEE.
% Asegurarse de que las citas en el texto usen corchetes, ej. [1], [2].
\begin{thebibliography}{9}
\bibitem{torvalds2001}
L. Torvalds y D. Diamond, \textit{Just for Fun: The Story of an Accidental Revolutionary}. HarperBusiness, 2001.

\bibitem{tanenbaum2015}
A. S. Tanenbaum y H. Bos, \textit{Modern Operating Systems}. 4.\,ed., Pearson, 2015.
\end{thebibliography}

% ============================================================
% ANEXOS
% ============================================================
\section{Anexos}
% [cite: 34, 87]
% Aquí se puede incluir material que complementa el informe pero que
% no es esencial para la comprensión principal[cite: 90, 91].

\vspace{0.5cm}
\hrule
\begin{center}
\textbf{\estudianteUno{} y \estudianteDos}\\
Estudiantes de \programa\\
\institucion\\
\fechaentrega{}
\end{center}

\end{document}